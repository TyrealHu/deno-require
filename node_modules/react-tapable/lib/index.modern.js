import{useEffect as t}from"react";class e{content(t){throw new Error("CodeFactory must be abstract")}create(t){let e;if(this.init(t),this.options&&this._args){switch(this.options.type){case"sync":e=new Function(this.args({}),'"use strict";\n'+this.header()+this.content({onError:t=>`throw ${t};\n`,onResult:t=>`return ${t};\n`,resultReturns:!0,onDone:()=>"",rethrowIfPossible:!0}));break;case"async":e=new Function(this.args({after:"_callback"}),'"use strict";\n'+this.header()+this.content({onError:t=>`_callback(${t});\n`,onResult:t=>`_callback(null, ${t});\n`,onDone:()=>"_callback();\n"}));break;case"promise":let t=!1;const n=this.content({onError:e=>(t=!0,`_error(${e});\n`),onResult:t=>`_resolve(${t});\n`,onDone:()=>"_resolve();\n"});let o="";o+='"use strict";\n',o+=this.header(),o+="return new Promise((function(_resolve, _reject) {\n",t&&(o+="var _sync = true;\n",o+="function _error(_err) {\n",o+="if(_sync)\n",o+="_resolve(Promise.resolve().then((function() { throw _err; })));\n",o+="else\n",o+="_reject(_err);\n",o+="};\n"),o+=n,t&&(o+="_sync = false;\n"),o+="}));\n",e=new Function(this.args({}),o)}return this.deinit(),e}}setup(t,e){e.taps.forEach(e=>{t.push(e.fn)})}init(t){this.options=t,this._args=t.args.slice()}deinit(){this.options=void 0,this._args=void 0}header(){let t="";return this.needContext()?t+="var _context = {};\n":t+="var _context;\n",t+="var fns = this.fns;\n",t}needContext(){if(this.options)for(const t of this.options.taps)if(t.context)return!0;return!1}callTap(t,{onError:e,onResult:n,onDone:o,rethrowIfPossible:s}){let r="";if(!this.options)return r;r+=`var _fn${t} = ${this.getTapFn(t)};\n`;const i=this.options.taps[t];switch(i.type){case"sync":s||(r+=`var _hasError${t} = false;\n`,r+="try {\n"),r+=n?`var _result${t} = _fn${t}(${this.args({before:i.context?"_context":void 0})});\n`:`_fn${t}(${this.args({before:i.context?"_context":void 0})});\n`,s||(r+="} catch(_err) {\n",r+=`_hasError${t} = true;\n`,r+=e("_err"),r+="}\n",r+=`if(!_hasError${t}) {\n`),n&&(r+=n("_result"+t)),o&&(r+=o()),s||(r+="}\n");break;case"async":let a="";a+=n?`(function(_err${t}, _result${t}) {\n`:`(function(_err${t}) {\n`,a+=`if(_err${t}) {\n`,a+=e("_err"+t),a+="} else {\n",n&&(a+=n("_result"+t)),o&&(a+=o()),a+="}\n",a+="})",r+=`_fn${t}(${this.args({before:i.context?"_context":void 0,after:a})});\n`;break;case"promise":r+=`var _hasResult${t} = false;\n`,r+=`var _promise${t} = _fn${t}(${this.args({before:i.context?"_context":void 0})});\n`,r+=`if (!_promise${t} || !_promise${t}.then)\n`,r+=`  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${t} + ')');\n`,r+=`_promise${t}.then((function(_result${t}) {\n`,r+=`_hasResult${t} = true;\n`,n&&(r+=n("_result"+t)),o&&(r+=o()),r+=`}), function(_err${t}) {\n`,r+=`if(_hasResult${t}) throw _err${t};\n`,r+=e("_err"+t),r+="});\n"}return r}callTapsSeries({onError:t,onResult:e,resultReturns:n,onDone:o,doneReturns:s,rethrowIfPossible:r}){if(!this.options||0===this.options.taps.length)return o();const i=this.options.taps.findIndex(t=>"sync"!==t.type),a=n||s;let l="",c=o,h=0;for(let n=this.options.taps.length-1;n>=0;n--){const s=n;c!==o&&("sync"!==this.options.taps[s].type||h++>20)&&(h=0,l+=`function _next${s}() {\n`,l+=c(),l+="}\n",c=()=>`${a?"return ":""}_next${s}();\n`);const p=c,u=t=>t?"":o(),f=this.callTap(s,{onError:e=>t(s,e,p,u),onResult:e&&(t=>e(s,t,p,u)),onDone:!e&&p,rethrowIfPossible:r&&(i<0||s<i)});c=()=>f}return l+=c(),l}callTapsLooping({onError:t,onDone:e,rethrowIfPossible:n}){if(!this.options||0===this.options.taps.length)return e();const o=this.options.taps.every(t=>"sync"===t.type);let s="";return o||(s+="var _looper = (function() {\n",s+="var _loopAsync = false;\n"),s+="var _loop;\n",s+="do {\n",s+="_loop = false;\n",s+=this.callTapsSeries({onError:t,onResult:(t,e,n,s)=>{let r="";return r+=`if(${e} !== undefined) {\n`,r+="_loop = true;\n",o||(r+="if(_loopAsync) _looper();\n"),r+=s(!0),r+="} else {\n",r+=n(),r+="}\n",r},onDone:e&&(()=>{let t="";return t+="if(!_loop) {\n",t+=e(),t+="}\n",t}),rethrowIfPossible:n&&o}),s+="} while(_loop);\n",o||(s+="_loopAsync = true;\n",s+="});\n",s+="_looper();\n"),s}callTapsParallel({onError:t,onResult:e,onDone:n,rethrowIfPossible:o,onTap:s=((t,e)=>e())}){if(!this.options)return"";if(this.options.taps.length<=1)return this.callTapsSeries({onError:t,onResult:e,onDone:n,rethrowIfPossible:o});let r="";r+="do {\n",r+=`var _counter = ${this.options.taps.length};\n`,n&&(r+="var _done = (function() {\n",r+=n(),r+="});\n");for(let i=0;i<this.options.taps.length;i++){const a=()=>n?"if(--_counter === 0) _done();\n":"--_counter;",l=t=>t||!n?"_counter = 0;\n":"_counter = 0;\n_done();\n";r+="if(_counter <= 0) break;\n",r+=s(i,()=>this.callTap(i,{onError:e=>{let n="";return n+="if(_counter > 0) {\n",n+=t(i,e,a,l),n+="}\n",n},onResult:e&&(t=>{let n="";return n+="if(_counter > 0) {\n",n+=e(i,t,a,l),n+="}\n",n}),onDone:!e&&(()=>a()),rethrowIfPossible:o}),a,l)}return r+="} while(false);\n",r}args({before:t,after:e}){let n=this._args||[];return t&&(n=[t].concat(n)),e&&(n=n.concat(e)),0===n.length?"":n.join(", ")}getTapFn(t){return`fns[${t}]`}getTap(t){return`_taps[${t}]`}}function n(){return(n=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t}).apply(this,arguments)}const o=((t,e)=>{let n=!0;return function(...e){return n&&(console.warn("DeprecationWarning: Hook.context is deprecated and will be removed"),n=!1),t.apply(this,e)}})(()=>{});class s{constructor(t,e){this._args=t||[],this.name=e||"",this.taps=[],this.once=!1,this._call=function(...t){this.call=this._createCall("sync");const e=this.call(...t);return this.afterInvoke(),e},this.call=this._call,this._callAsync=function(...t){this.callAsync=this._createCall("async");const e=this.callAsync(...t);return this.afterInvoke(),e},this.callAsync=this._callAsync,this._promise=function(...t){this.promise=this._createCall("promise");const e=this.promise(...t);return this.afterInvoke(),e},this.promise=this._promise}afterInvoke(){this.once&&(this.taps=this.taps.filter(t=>!t.once),this._resetCompilation(),this.once=!1)}compile(t){throw new Error("Abstract: should be overridden")}isUsed(){return this.taps.length>0}withOptions(t){const e=e=>Object.assign({},t,"string"==typeof e?{name:e}:e);return{name:this.name,tap:(t,n)=>this.tap(e(t),n),tapAsync:(t,n)=>this.tapAsync(e(t),n),tapPromise:(t,n)=>this.tapPromise(e(t),n),isUsed:()=>this.isUsed(),withOptions:t=>this.withOptions(e(t))}}_createCall(t){return this.compile({taps:this.taps,args:this._args,type:t})}_resetCompilation(){this.call=this._call,this.callAsync=this._callAsync,this.promise=this._promise}_insert(t){this._resetCompilation(),!this.once&&t.once&&(this.once=!0),this.taps.push(t)}_tap(t,e,s){const r={name:"",context:!1,once:!1};if("string"==typeof e)r.name=e.trim();else{if("object"!=typeof e||null===e)throw new Error("Invalid tap options");if("string"!=typeof e.name||""===e.name)throw new Error("Missing name for tap");r.name=e.name,e.context&&(o(),r.context=e.context),r.once=Boolean(e.once)}this._insert(n({type:t,fn:s},r))}tap(t,e){this._tap("sync",t,e)}tapAsync(t,e){this._tap("async",t,e)}tapPromise(t,e){this._tap("promise",t,e)}_isRegistered(t,e){return-1!==this._tapHookIndexOf(t,e)}_deleteTapHook(t,e){this._resetCompilation(),this.taps=this.taps.filter(n=>!(n.type===t&&n.fn===e))}_replaceTapHook(t,e,n){this._resetCompilation();let o=!1;for(const s of this.taps)s.type===t&&s.fn===e&&(o=!0,s.fn=n);return o}_tapHookIndexOf(t,e){let n=-1;for(let o=0;o<this.taps.length;o++)if(this.taps[o].fn===e&&this.taps[o].type===t){n=o;break}return n}}const r=new class extends e{content({onError:t,onResult:e,onDone:n}){let o="";return this.options&&e?(o+=`var _results = new Array(${this.options.taps.length});\n`,o+="var _checkDone = function() {\n",o+="for(var i = 0; i < _results.length; i++) {\n",o+="var item = _results[i];\n",o+="if(item === undefined) return false;\n",o+="if(item.result !== undefined) {\n",o+=e("item.result"),o+="return true;\n",o+="}\n",o+="if(item.error) {\n",o+=t("item.error"),o+="return true;\n",o+="}\n",o+="}\n",o+="return false;\n",o+="}\n",o+=this.callTapsParallel({onError:(t,e,n,o)=>{let s="";return s+=`if(${t} < _results.length && ((_results.length = ${t+1}), (_results[${t}] = { error: ${e} }), _checkDone())) {\n`,s+=o(!0),s+="} else {\n",s+=n(),s+="}\n",s},onResult:(t,e,n,o)=>{let s="";return s+=`if(${t} < _results.length && (${e} !== undefined && (_results.length = ${t+1}), (_results[${t}] = { result: ${e} }), _checkDone())) {\n`,s+=o(!0),s+="} else {\n",s+=n(),s+="}\n",s},onTap:(t,e,n,o)=>{let s="";return t>0&&(s+=`if(${t} >= _results.length) {\n`,s+=n(),s+="} else {\n"),s+=e(),t>0&&(s+="}\n"),s},onDone:n}),o):o}};class i extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],r.setup(this.fns,t),r.create(t)},this.call=()=>{throw new Error("call is not supported on a AsyncParallelBailHook")},this._call=()=>{throw new Error("call is not supported on a AsyncParallelBailHook")}}}const a=new class extends e{content({onError:t,onDone:e}){return this.callTapsParallel({onError:(e,n,o,s)=>t(n)+s(!0),onDone:e})}};class l extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],a.setup(this.fns,t),a.create(t)},this.call=()=>{throw new Error("call is not supported on a AsyncParallelHook")},this._call=()=>{throw new Error("call is not supported on a AsyncParallelHook")}}}const c=new class extends e{content({onError:t,onResult:e,resultReturns:n,onDone:o}){return this.callTapsSeries({onError:(e,n,o,s)=>t(n)+s(!0),onResult:(t,n,o)=>`if(${n} !== undefined) {\n${e(n)}\n} else {\n${o()}}\n`,resultReturns:n,onDone:o})}};class h extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],c.setup(this.fns,t),c.create(t)},this.call=()=>{throw new Error("call is not supported on a AsyncSeriesBailHook")},this._call=()=>{throw new Error("call is not supported on a AsyncSeriesBailHook")}}}const p=new class extends e{content({onError:t,onDone:e}){return this.callTapsSeries({onError:(e,n,o,s)=>t(n)+s(!0),onDone:e})}};class u extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],p.setup(this.fns,t),p.create(t)},this.call=()=>{throw new Error("call is not supported on a AsyncSeriesHook")},this._call=()=>{throw new Error("call is not supported on a AsyncSeriesHook")}}}const f=new class extends e{content({onError:t,onDone:e}){return this.callTapsLooping({onError:(e,n,o,s)=>t(n)+s(!0),onDone:e})}};class _ extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],f.setup(this.fns,t),f.create(t)},this.call=()=>{throw new Error("call is not supported on a AsyncSeriesLoopHook")},this._call=()=>{throw new Error("call is not supported on a AsyncSeriesLoopHook")}}}const d=new class extends e{content({onError:t,onResult:e}){return this.callTapsSeries({onError:(e,n,o,s)=>t(n)+s(!0),onResult:(t,e,n)=>{let o="";if(o+=`if(${e} !== undefined) {\n`,o+=`if (!(${e} instanceof Array)){ \n`,o+=`${e} = [${e}]\n`,o+="}\n",this._args)for(let t=0;t<this._args.length;t++)o+=[`if (${e}[${t}]) {`,`${this._args[t]} = ${e}[${t}];`,"}\n"].join("\n");return o+="}\n",o+=n(),o},onDone:()=>e(`[${this._args.toString()}]`)})}};class m extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],d.setup(this.fns,t),d.create(t)},this.call=()=>{throw new Error("call is not supported on a AsyncSeriesWaterfallAllHook")},this._call=()=>{throw new Error("call is not supported on a AsyncSeriesWaterfallAllHook")}}}const w=new class extends e{content({onError:t,onResult:e}){return this.callTapsSeries({onError:(e,n,o,s)=>t(n)+s(!0),onResult:(t,e,n)=>{let o="";return o+=`if(${e} !== undefined) {\n`,o+=`${this._args[0]} = ${e};\n`,o+="}\n",o+=n(),o},onDone:()=>e(this._args[0])})}};class y extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],w.setup(this.fns,t),w.create(t)},this.call=()=>{throw new Error("call is not supported on a AsyncSeriesWaterfallHook")},this._call=()=>{throw new Error("call is not supported on a AsyncSeriesWaterfallHook")}}}const k=new Map;let g=0;function $(){return++g}const E={tap:"sync",tapAsync:"async",tapPromise:"promise"};function b(t){throw new Error("react-tapable: "+t)}class A{constructor(t,e){this.name=t,this.hooks=e,this.count=Object.keys(e).reduce((t,e)=>(t[e]=0,t),{})}call(t,...e){const n=this.getHook(t);if(!n)throw new Error(`hook doesn't exist in controller,it' s name : ${t} `);return n.call(...e)}callAsync(t,...e){const n=this.getHook(t);if(!n)throw new Error(`hook doesn't exist in controller,it' s name : ${t} `);return n.callAsync(...e)}promise(t,...e){const n=this.getHook(t);if(!n)throw new Error(`hook doesn't exist in controller,it' s name : ${t} `);return n.promise(...e)}getHook(t){if(this.hooks.hasOwnProperty(t))return this.hooks[t]}getHooksNameMap(){if(!this.hooks)return{};const t={};return Object.keys(this.hooks).reduce((t,e)=>(t[e]=e,t),t),t}getHookTapName(t){return`${this.name}:${t}`}tapHook(t,e){const n=this.getHook(t.hook);n||b("tapHook Cannot find hook by key "+t.hook),"tap"!==t.mode&&"tapAsync"!==t.mode&&"tapPromise"!==t.mode&&b("tapHook rawOptions' mode must be tap/tapAsync/tapPromise, but get "+t.mode),n[t.mode]({context:Boolean(t.context),name:this.getHookTapName(t.hook),once:Boolean(t.once)},e)}removeTapHook(t,e,n){const o=this.getHook(t);o||b("removeTapHook Cannot find hook by key "+t),"tap"!==e&&"tapAsync"!==e&&"tapPromise"!==e&&b("removeTapHook mode must be tap/tapAsync/tapPromise, but get "+e),o._deleteTapHook(E[e],n)}}function x(e,n){const o=$();k.has(e+o+"")&&console.warn(`react-tapable: controller: ${e} has been registed, and it will be covered`);const s=new A(e,n);return k.set(e+o,s),{HooksNameMap:s.getHooksNameMap(),call:(t,...e)=>s.call(t,...e),callAsync:(t,...e)=>s.callAsync(t,...e),promise:(t,...e)=>s.promise(t,...e),tapHook:(t,e)=>s.tapHook(t,e),removeTapHook:(t,e,n)=>s.removeTapHook(t,e,n),useTapable:(n,s,r)=>function(e,n,o,s){const{hook:r,context:i,fn:a,useAliasArr:l,name:c,type:h,mode:p,once:u}=function(t,e,n,o){const s={},r=k.get(t);if("string"!=typeof e.mode?b("useTapable rawOptions' mode must be string"):"tap"!==e.mode&&"tapAsync"!==e.mode&&"tapPromise"!==e.mode?b("useTapable rawOptions' mode must be tap/tapAsync/tapPromise, but get "+e.mode):s.mode=e.mode,"string"!=typeof e.hook)b("useTapable rawOptions' hook must be string, but get "+typeof e.hook);else{const t=r.getHook(e.hook);t||b("useTapable please check to see if the controller has this hook "+e.hook),s.hook=t}return s.type=E[s.mode],n instanceof Function?(s.hook._isRegistered(s.type,n)&&b("useTapable rawOptions' fn has been registered"),s.fn=n):b("useTapable rawOptions' fn must be function"),s.useAliasArr=o||[],s.context=Boolean(e.context),s.name=r.getHookTapName(e.hook),s.once=Boolean(e.once),s}(e,n,o,s);t(()=>(r[p]({context:i,name:c,once:u},a),()=>{r._deleteTapHook(h,a)}),[...l])}(e+o,n,s,r)}}const H=new class extends e{content({onError:t,onResult:e,resultReturns:n,onDone:o,rethrowIfPossible:s}){return this.callTapsSeries({onError:(e,n)=>t(n),onResult:(t,n,o)=>`if(${n} !== undefined) {\n${e(n)};\n} else {\n${o()}}\n`,resultReturns:n,onDone:o,rethrowIfPossible:s})}};class P extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],H.setup(this.fns,t),H.create(t)}}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}const v=new class extends e{content({onError:t,onDone:e,rethrowIfPossible:n}){return this.callTapsSeries({onError:(e,n)=>t(n),onDone:e,rethrowIfPossible:n})}};class T extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],v.setup(this.fns,t),v.create(t)}}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}const R=new class extends e{content({onError:t,onDone:e,rethrowIfPossible:n}){return this.callTapsLooping({onError:(e,n)=>t(n),onDone:e,rethrowIfPossible:n})}};class D extends s{constructor(t,e){super(t,e),this.compile=function(t){return this.fns=[],R.setup(this.fns,t),R.create(t)}}tapAsync(){throw new Error("tapAsync is not supported on a SyncLoopHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncLoopHook")}}const S=new class extends e{content({onError:t,onResult:e,resultReturns:n,rethrowIfPossible:o}){return this.callTapsSeries({onError:(e,n)=>t(n),onResult:(t,e,n)=>{let o="";if(o+=`if(${e} !== undefined) {\n`,o+=`if (!(${e} instanceof Array)){ \n`,o+=`${e} = [${e}]\n`,o+="}\n",this._args)for(let t=0;t<this._args.length;t++)o+=[`if (${e}[${t}]) {`,`${this._args[t]} = ${e}[${t}];`,"}\n"].join("\n");return o+="}\n",o+=n(),o},onDone:()=>e(`[${this._args.toString()}]`),doneReturns:n,rethrowIfPossible:o})}};class I extends s{constructor(t,e){if(t.length<1)throw new Error("WaterfallAll hooks must have at least one argument");super(t,e),this.compile=function(t){return this.fns=[],S.setup(this.fns,t),S.create(t)}}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}const O=new class extends e{content({onError:t,onResult:e,resultReturns:n,rethrowIfPossible:o}){return this.callTapsSeries({onError:(e,n)=>t(n),onResult:(t,e,n)=>{let o="";return o+=`if(${e} !== undefined) {\n`,o+=`${this._args[0]} = ${e};\n`,o+="}\n",o+=n(),o},onDone:()=>e(this._args[0]),doneReturns:n,rethrowIfPossible:o})}};class C extends s{constructor(t,e){if(t.length<1)throw new Error("Waterfall hooks must have at least one argument");super(t,e),this.compile=function(t){return this.fns=[],O.setup(this.fns,t),O.create(t)}}tapAsync(){throw new Error("tapAsync is not supported on a SyncHook")}tapPromise(){throw new Error("tapPromise is not supported on a SyncHook")}}export default x;export{i as AsyncParallelBailHook,l as AsyncParallelHook,h as AsyncSeriesBailHook,u as AsyncSeriesHook,_ as AsyncSeriesLoopHook,m as AsyncSeriesWaterfallAllHook,y as AsyncSeriesWaterfallHook,A as Controller,P as SyncBailHook,T as SyncHook,D as SyncLoopHook,I as SyncWaterfallAllHook,C as SyncWaterfallHook,x as createTapableController};
