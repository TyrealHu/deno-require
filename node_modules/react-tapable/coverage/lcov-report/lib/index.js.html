
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for lib/index.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../prettify.css" />
    <link rel="stylesheet" href="../base.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../index.html">All files</a> / <a href="index.html">lib</a> index.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">36.27% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>173/477</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">27.64% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>76/275</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">32.73% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>72/220</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>1/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a></td><td class="line-coverage quiet"><span class="cline-any cline-yes">24x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">var n=require("react");function t(){return(t=Object.assign?Object.assign.bind():<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >1;</span>t&lt;arguments.length;t++){var r=<span class="cstat-no" title="statement not covered" >arguments[t];<span class="cstat-no" title="statement not covered" ></span>for(var o in r)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(r,o)&amp;&amp;(n[o]=r[o])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn n}</span>)</span>.apply(this,arguments)}function r(n,t){var r,o;n.prototype=Object.create(t.prototype),n.prototype.constructor=n,r=n,o=t,(Object.setPrototypeOf?Object.setPrototypeOf.bind():<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >return n.__proto__=t,n}</span>)</span>(r,o)}function <span class="fstat-no" title="function not covered" >o(</span>n,t){<span class="cstat-no" title="statement not covered" >(null==t||t&gt;n.length)&amp;&amp;(t=n.length);<span class="cstat-no" title="statement not covered" >f</span>or(var r=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >new Array(t);</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >o[r]=n[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>function e(n,t){var r="undefined"!=typeof Symbol&amp;&amp;n[Symbol.iterator]||<span class="branch-2 cbranch-no" title="branch not covered" >n["@@iterator"];<span class="missing-if-branch" title="else path not taken" >E</span></span>if(r)return(r=r.call(n)).next.bind(r);<span class="cstat-no" title="statement not covered" >if(Array.isArray(n)||(r=<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >if("string"==typeof n)<span class="cstat-no" title="statement not covered" >return o(n,void 0);v</span></span>ar r=<span class="cstat-no" title="statement not covered" >Object.prototype.toString.call(n).slice(8,-1);<span class="cstat-no" title="statement not covered" ></span>return"Object"===r&amp;&amp;n.constructor&amp;&amp;(r=n.constructor.name),"Map"===r||"Set"===r?Array.from(n):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?o(n,void 0):void 0}</span>}</span>(n))||t&amp;&amp;n&amp;&amp;"number"==typeof n.length){<span class="cstat-no" title="statement not covered" >r&amp;&amp;(n=r);v</span>ar e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e&gt;=n.length?{done:!0}:{done:!1,value:n[e++]}}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}</span>var s,i,a,c=function(){function n(){}var t=n.prototype;return t.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >throw new Error("CodeFactory must be abstract")}</span>,t.create=function(n){var t;<span class="missing-if-branch" title="else path not taken" >E</span>if(this.init(n),this.options&amp;&amp;this._args){switch(this.options.type){case"sync":t=new Function(this.args({}),'"use strict";\n'+this.header()+this.content({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return"throw "+n+";\n"}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return"return "+n+";\n"}</span>,resultReturns:!0,onDone:function(){return""},rethrowIfPossible:!0}));break;<span class="branch-1 cbranch-no" title="branch not covered" >case"async":<span class="cstat-no" title="statement not covered" >t=new Function(this.args({after:"_callback"}),'"use strict";\n'+this.header()+this.content({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return"_callback("+n+");\n"}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return"_callback(null, "+n+");\n"}</span>,onDone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"_callback();\n"}</span>}));<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-2 cbranch-no" title="branch not covered" >c</span></span>ase"promise":var r=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >this.content({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return r=!0,"_error("+n+");\n"}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return"_resolve("+n+");\n"}</span>,onDone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"_resolve();\n"}</span>}),</span>e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>e+='"use strict";\n',e+=this.header(),e+="return new Promise((function(_resolve, _reject) {\n",r&amp;&amp;(e+="var _sync = true;\n",e+="function _error(_err) {\n",e+="if(_sync)\n",e+="_resolve(Promise.resolve().then((function() { throw _err; })));\n",e+="else\n",e+="_reject(_err);\n",e+="};\n"),e+=o,r&amp;&amp;(e+="_sync = false;\n"),e+="}));\n",t=new Function(this.args({}),e)}</span></span>return this.deinit(),t}},t.setup=function(n,t){t.taps.forEach(function(t){n.push(t.fn)})},t.init=function(n){this.options=n,this._args=n.args.slice()},t.deinit=function(){this.options=void 0,this._args=void 0},t.header=function(){var n="";return this.needContext()?<span class="branch-0 cbranch-no" title="branch not covered" >n+="var _context = {};\n":</span>n+="var _context;\n",n+"var fns = this.fns;\n"},t.needContext=function(){<span class="missing-if-branch" title="else path not taken" >E</span>if(this.options)for(var n,t=e(this.options.taps);!(n=t()).done;)<span class="missing-if-branch" title="if path not taken" >I</span>if(n.value.context)<span class="cstat-no" title="statement not covered" >return!0;r</span>eturn!1},t.callTap=function(n,t){var r=t.onError,o=t.onResult,e=t.onDone,s=t.rethrowIfPossible,i="";<span class="missing-if-branch" title="if path not taken" >I</span>if(!this.options)<span class="cstat-no" title="statement not covered" >return i;i</span>+="var _fn"+n+" = "+this.getTapFn(n)+";\n";var a=this.options.taps[n];switch(a.type){case"sync":s||(<span class="branch-1 cbranch-no" title="branch not covered" >i+="var _hasError"+n+" = false;\n",i+="try {\n")</span>,i+=o?<span class="branch-0 cbranch-no" title="branch not covered" >"var _result"+n+" = _fn"+n+"("+this.args({before:a.context?"_context":void 0})+");\n":</span>"_fn"+n+"("+this.args({before:a.context?<span class="branch-0 cbranch-no" title="branch not covered" >"_context":</span>void 0})+");\n",s||(<span class="branch-1 cbranch-no" title="branch not covered" >i+="} catch(_err) {\n",i+="_hasError"+n+" = true;\n",i+=r("_err"),i+="}\n",i+="if(!_hasError"+n+") {\n")</span>,o&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >i+=o("_result"+n))</span>,e&amp;&amp;(i+=e()),s||(<span class="branch-1 cbranch-no" title="branch not covered" >i+="}\n")</span>;break;<span class="branch-1 cbranch-no" title="branch not covered" >case"async":var c=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>c+=o?"(function(_err"+n+", _result"+n+") {\n":"(function(_err"+n+") {\n",c+="if(_err"+n+") {\n",c+=r("_err"+n),c+="} else {\n",o&amp;&amp;(c+=o("_result"+n)),e&amp;&amp;(c+=e()),c+="}\n",i+="_fn"+n+"("+this.args({before:a.context?"_context":void 0,after:c+="})"})+");\n";<span class="cstat-no" title="statement not covered" >b</span>reak;<span class="branch-2 cbranch-no" title="branch not covered" >c</span></span>ase"promise":<span class="cstat-no" title="statement not covered" >i+="var _hasResult"+n+" = false;\n",i+="var _promise"+n+" = _fn"+n+"("+this.args({before:a.context?"_context":void 0})+");\n",i+="if (!_promise"+n+" || !_promise"+n+".then)\n",i+="  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise"+n+" + ')');\n",i+="_promise"+n+".then((function(_result"+n+") {\n",i+="_hasResult"+n+" = true;\n",o&amp;&amp;(i+=o("_result"+n)),e&amp;&amp;(i+=e()),i+="}), function(_err"+n+") {\n",i+="if(_hasResult"+n+") throw _err"+n+";\n",i+=r("_err"+n),i+="});\n"}</span></span>return i},t.callTapsSeries=function(n){var t=this,r=n.onError,o=n.onResult,e=n.resultReturns,s=n.onDone,i=n.doneReturns,a=n.rethrowIfPossible;<span class="missing-if-branch" title="if path not taken" >I</span>if(!this.options||0===this.options.taps.length)<span class="cstat-no" title="statement not covered" >return s();f</span>or(var c=this.options.taps.findIndex(function(n){return"sync"!==n.type}),u=e||i,l="",f=s,p=0,h=function(n){var e=n;f!==s&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >"sync"!==t.options.taps[e].type|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >p++&gt;20)</span>&amp;&amp;(<span class="branch-3 cbranch-no" title="branch not covered" >p=0,l+="function _next"+e+"() {\n",l+=f(),l+="}\n",f=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(u?"return ":"")+"_next"+e+"();\n"}</span>)</span>;var i=f,h=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n?"":s()}</span>,y=t.callTap(e,{onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return r(e,n,i,h)}</span>,onResult:o&amp;&amp;<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return o(e,n,i,h)}</span>,</span>onDone:!o&amp;&amp;i,rethrowIfPossible:a&amp;&amp;(c&lt;0||<span class="branch-2 cbranch-no" title="branch not covered" >e&lt;c)</span>});f=function(){return y}},y=this.options.taps.length-1;y&gt;=0;y--)h(y);return l+=f()},t.callTapsLooping=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError,</span>r=<span class="cstat-no" title="statement not covered" >n.onDone,</span>o=<span class="cstat-no" title="statement not covered" >n.rethrowIfPossible;<span class="cstat-no" title="statement not covered" ></span>if(!this.options||0===this.options.taps.length)<span class="cstat-no" title="statement not covered" >return r();v</span></span>ar e=<span class="cstat-no" title="statement not covered" >this.options.taps.every(<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return"sync"===n.type}</span>),</span>s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e||(s+="var _looper = (function() {\n",s+="var _loopAsync = false;\n"),s+="var _loop;\n",s+="do {\n",s+="_loop = false;\n",s+=this.callTapsSeries({onError:t,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,r,o){var s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return s+="if("+t+" !== undefined) {\n",s+="_loop = true;\n",e||(s+="if(_loopAsync) _looper();\n"),s+=o(!0),s+="} else {\n",(s+=r())+"}\n"}</span>,onDone:r&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(){var n=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return n+="if(!_loop) {\n",(n+=r())+"}\n"}</span>,rethrowIfPossible:o&amp;&amp;e}),s+="} while(_loop);\n",e||(s+="_loopAsync = true;\n",s+="});\n",s+="_looper();\n"),s}</span>,t.callTapsParallel=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >n.onError,</span>o=<span class="cstat-no" title="statement not covered" >n.onResult,</span>e=<span class="cstat-no" title="statement not covered" >n.onDone,</span>s=<span class="cstat-no" title="statement not covered" >n.rethrowIfPossible,</span>i=<span class="cstat-no" title="statement not covered" >n.onTap,</span>a=<span class="cstat-no" title="statement not covered" >void 0===i?<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >return t()}</span>:i;<span class="cstat-no" title="statement not covered" ></span>if(!this.options)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >i</span></span>f(this.options.taps.length&lt;=1)<span class="cstat-no" title="statement not covered" >return this.callTapsSeries({onError:r,onResult:o,onDone:e,rethrowIfPossible:s});v</span></span>ar c=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>c+="do {\n",c+="var _counter = "+this.options.taps.length+";\n",e&amp;&amp;(c+="var _done = (function() {\n",c+=e(),c+="});\n");<span class="cstat-no" title="statement not covered" >f</span>or(var u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n){var i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e?"if(--_counter === 0) _done();\n":"--_counter;"}</span>,</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n||!e?"_counter = 0;\n":"_counter = 0;\n_done();\n"}</span>;<span class="cstat-no" title="statement not covered" ></span>c+="if(_counter &lt;= 0) break;\n",c+=a(n,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.callTap(n,{onError:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var o=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return o+="if(_counter &gt; 0) {\n",(o+=r(n,t,i,u))+"}\n"}</span>,onResult:o&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return r+="if(_counter &gt; 0) {\n",(r+=o(n,t,i,u))+"}\n"}</span>,onDone:!o&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i()}</span>,rethrowIfPossible:s})}</span>,i,u)}</span>,</span>l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;this.options.taps.length;l++)<span class="cstat-no" title="statement not covered" >u(l);<span class="cstat-no" title="statement not covered" >r</span></span>eturn c+="} while(false);\n"}</span>,t.args=function(n){var t=n.before,r=n.after,o=this._args||<span class="branch-1 cbranch-no" title="branch not covered" >[];</span>return t&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o=[t].concat(o))</span>,r&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >o=o.concat(r))</span>,0===o.length?"":<span class="branch-1 cbranch-no" title="branch not covered" >o.join(", ")}</span>,t.getTapFn=function(n){return"fns["+n+"]"},t.getTap=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return"_taps["+n+"]"}</span>,n}(),u=(s=<span class="fstat-no" title="function not covered" >fu</span>nction(){},i="Hook.context is deprecated and will be removed",a=!0,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a&amp;&amp;(console.warn("DeprecationWarning: "+i),a=!1),s.apply(this,[].slice.call(arguments))}</span>),l=function(){function n(n,t){this._args=n||<span class="branch-1 cbranch-no" title="branch not covered" >[],</span>this.name=t||"",this.taps=[],this._call=function(){return this.call=this._createCall("sync"),this.call.apply(this,[].slice.call(arguments))},this.call=this._call,this._callAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.callAsync=this._createCall("async"),this.callAsync.apply(this,[].slice.call(arguments))}</span>,this.callAsync=this._callAsync,this._promise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.promise=this._createCall("promise"),this.promise.apply(this,[].slice.call(arguments))}</span>,this.promise=this._promise}var r=n.prototype;return r.compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >throw new Error("Abstract: should be overridden")}</span>,r.isUsed=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this.taps.length&gt;0}</span>,r.withOptions=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.assign({},n,"string"==typeof t?{name:t}:t)}</span>;<span class="cstat-no" title="statement not covered" ></span>return{name:this.name,tap:<span class="fstat-no" title="function not covered" >fu</span>nction(n,o){<span class="cstat-no" title="statement not covered" >return t.tap(r(n),o)}</span>,tapAsync:<span class="fstat-no" title="function not covered" >fu</span>nction(n,o){<span class="cstat-no" title="statement not covered" >return t.tapAsync(r(n),o)}</span>,tapPromise:<span class="fstat-no" title="function not covered" >fu</span>nction(n,o){<span class="cstat-no" title="statement not covered" >return t.tapPromise(r(n),o)}</span>,isUsed:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.isUsed()}</span>,withOptions:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return t.withOptions(r(n))}</span>}}</span>,r._createCall=function(n){return this.compile({taps:this.taps,args:this._args,type:n})},r._resetCompilation=function(){this.call=this._call,this.callAsync=this._callAsync,this.promise=this._promise},r._insert=function(n){this._resetCompilation(),this.taps.push(n)},r._tap=function(n,r,o){var e={name:"",context:!1};<span class="missing-if-branch" title="if path not taken" >I</span>if("string"==typeof r)<span class="cstat-no" title="statement not covered" >e.name=r.trim();e</span>lse{<span class="missing-if-branch" title="if path not taken" >I</span>if("object"!=typeof r||null===r)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid tap options");<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f("string"!=typeof r.name||""===r.name)<span class="cstat-no" title="statement not covered" >throw new Error("Missing name for tap");e</span>.name=r.name,r.context&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >u(),e.context=r.context)</span>}this._insert(t({type:n,fn:o},e))},r.tap=function(n,t){this._tap("sync",n,t)},r.tapAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >this._tap("async",n,t)}</span>,r.tapPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >this._tap("promise",n,t)}</span>,r._isRegistered=function(n,t){return-1!==this._tapHookIndexOf(n,t)},r._deleteTapHook=function(n,t){this._resetCompilation(),this.taps=this.taps.filter(function(r){return!(r.type===n&amp;&amp;r.fn===t)})},r._replaceTapHook=<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,r){<span class="cstat-no" title="statement not covered" >this._resetCompilation();<span class="cstat-no" title="statement not covered" >f</span>or(var o,s=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >e(this.taps);</span>!(o=i()).done;){var a=<span class="cstat-no" title="statement not covered" >o.value;<span class="cstat-no" title="statement not covered" ></span>a.type===n&amp;&amp;a.fn===t&amp;&amp;(s=!0,a.fn=r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>,r._tapHookIndexOf=function(n,t){for(var r=-1,o=0;o&lt;this.taps.length;o++)<span class="cstat-no" title="statement not covered" >if(this.taps[o].fn===t&amp;&amp;this.taps[o].type===n){<span class="cstat-no" title="statement not covered" >r=o;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>r</span>eturn r},n}(),f=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError,</span>r=<span class="cstat-no" title="statement not covered" >n.onResult,</span>o=<span class="cstat-no" title="statement not covered" >n.onDone,</span>e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return this.options&amp;&amp;r?(e+="var _results = new Array("+this.options.taps.length+");\n",e+="var _checkDone = function() {\n",e+="for(var i = 0; i &lt; _results.length; i++) {\n",e+="var item = _results[i];\n",e+="if(item === undefined) return false;\n",e+="if(item.result !== undefined) {\n",e+=r("item.result"),e+="return true;\n",e+="}\n",e+="if(item.error) {\n",e+=t("item.error"),e+="return true;\n",e+="}\n",e+="}\n",e+="return false;\n",e+="}\n",e+=this.callTapsParallel({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,r,o){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e+="if("+n+" &lt; _results.length &amp;&amp; ((_results.length = "+(n+1)+"), (_results["+n+"] = { error: "+t+" }), _checkDone())) {\n",e+=o(!0),e+="} else {\n",(e+=r())+"}\n"}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,r,o){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e+="if("+n+" &lt; _results.length &amp;&amp; ("+t+" !== undefined &amp;&amp; (_results.length = "+(n+1)+"), (_results["+n+"] = { result: "+t+" }), _checkDone())) {\n",e+=o(!0),e+="} else {\n",(e+=r())+"}\n"}</span>,onTap:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,r,o){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return n&gt;0&amp;&amp;(e+="if("+n+" &gt;= _results.length) {\n",e+=r(),e+="} else {\n"),e+=t(),n&gt;0&amp;&amp;(e+="}\n"),e}</span>,onDone:o})):e}</span>,t}(c)),p=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],f.setup(this.fns,n),f.create(n)}</span>,o.call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncParallelBailHook")}</span>,o._call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncParallelBailHook")}</span>,o}</span>return r(t,n),t}(l),h=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsParallel({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o,e){<span class="cstat-no" title="statement not covered" >return t(r)+e(!0)}</span>,onDone:n.onDone})}</span>,t}(c)),y=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],h.setup(this.fns,n),h.create(n)}</span>,o.call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncParallelHook")}</span>,o._call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncParallelHook")}</span>,o}</span>return r(t,n),t}(l),_=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError,</span>r=<span class="cstat-no" title="statement not covered" >n.onResult;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o,e){<span class="cstat-no" title="statement not covered" >return t(r)+e(!0)}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,o){<span class="cstat-no" title="statement not covered" >return"if("+t+" !== undefined) {\n"+r(t)+"\n} else {\n"+o()+"}\n"}</span>,resultReturns:n.resultReturns,onDone:n.onDone})}</span>,t}(c)),w=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],_.setup(this.fns,n),_.create(n)}</span>,o.call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesBailHook")}</span>,o._call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesBailHook")}</span>,o}</span>return r(t,n),t}(l),v=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o,e){<span class="cstat-no" title="statement not covered" >return t(r)+e(!0)}</span>,onDone:n.onDone})}</span>,t}(c)),d=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],v.setup(this.fns,n),v.create(n)}</span>,o.call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesHook")}</span>,o._call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesHook")}</span>,o}</span>return r(t,n),t}(l),m=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsLooping({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o,e){<span class="cstat-no" title="statement not covered" >return t(r)+e(!0)}</span>,onDone:n.onDone})}</span>,t}(c)),g=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],m.setup(this.fns,n),m.create(n)}</span>,o.call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesLoopHook")}</span>,o._call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesLoopHook")}</span>,o}</span>return r(t,n),t}(l),k=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >n.onError,</span>o=<span class="cstat-no" title="statement not covered" >n.onResult;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,o,e){<span class="cstat-no" title="statement not covered" >return r(t)+e(!0)}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(e+="if("+r+" !== undefined) {\n",e+="if (!("+r+" instanceof Array)){ \n",e+=r+" = ["+r+"]\n",e+="}\n",t._args)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t._args.length;s++)<span class="cstat-no" title="statement not covered" >e+=["if ("+r+"["+s+"]) {",t._args[s]+" = "+r+"["+s+"];","}\n"].join("\n");<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn(e+="}\n")+o()}</span>,onDone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o("["+t._args.toString()+"]")}</span>})}</span>,t}(c)),b=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],k.setup(this.fns,n),k.create(n)}</span>,o.call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesWaterfallAllHook")}</span>,o._call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesWaterfallAllHook")}</span>,o}</span>return r(t,n),t}(l),E=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >n.onError,</span>o=<span class="cstat-no" title="statement not covered" >n.onResult;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,o,e){<span class="cstat-no" title="statement not covered" >return r(t)+e(!0)}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e+="if("+r+" !== undefined) {\n",e+=t._args[0]+" = "+r+";\n",(e+="}\n")+o()}</span>,onDone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o(t._args[0])}</span>})}</span>,t}(c)),A=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],E.setup(this.fns,n),E.create(n)}</span>,o.call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesWaterfallHook")}</span>,o._call=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("call is not supported on a AsyncSeriesWaterfallHook")}</span>,o}</span>return r(t,n),t}(l),H=new Map,P=0;function <span class="fstat-no" title="function not covered" >S(</span>){<span class="cstat-no" title="statement not covered" >return++P}</span>var x={tap:"sync",tapAsync:"async",tapPromise:"promise"},R=function(){function <span class="fstat-no" title="function not covered" >n(</span>n,t){<span class="cstat-no" title="statement not covered" >this.name=n,this.hooks=t,this.count=Object.keys(t).reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >return n[t]=0,n}</span>,{})}</span>var t=n.prototype;return t.call=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this.getHook(n);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >throw new Error("hook doesn't exist in controller,it' s name : "+n+" ");<span class="cstat-no" title="statement not covered" >t</span></span>.call.apply(t,[].slice.call(arguments,1))}</span>,t.callAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this.getHook(n);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >throw new Error("hook doesn't exist in controller,it' s name : "+n+" ");<span class="cstat-no" title="statement not covered" >t</span></span>.callAsync.apply(t,[].slice.call(arguments,1))}</span>,t.promise=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this.getHook(n);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >throw new Error("hook doesn't exist in controller,it' s name : "+n+" ");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.promise.apply(t,[].slice.call(arguments,1))}</span>,t.getHook=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >if(this.hooks.hasOwnProperty(n))<span class="cstat-no" title="statement not covered" >return this.hooks[n]}</span></span>,t.getHooksNameMap=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!this.hooks)<span class="cstat-no" title="statement not covered" >return{};v</span></span>ar n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(this.hooks).reduce(<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >return n[t]=t,n}</span>,n),n}</span>,t.getHookTapName=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.name+":"+n}</span>,n}();function <span class="fstat-no" title="function not covered" >D(</span>t,r){var o=<span class="cstat-no" title="statement not covered" >S();<span class="cstat-no" title="statement not covered" ></span>H.has(t+o+"")&amp;&amp;console.warn("react-tapable: controller: "+t+" has been registed, and it will be covered");v</span>ar e=<span class="cstat-no" title="statement not covered" >new R(t,r);<span class="cstat-no" title="statement not covered" ></span>return H.set(t+o,e),{HooksNameMap:e.getHooksNameMap(),tapableCall:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.call.apply(e,[n].concat([].slice.call(arguments,1)))}</span>,tapableCallAsync:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.callAsync.apply(e,[n].concat([].slice.call(arguments,1)))}</span>,tapablePromise:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.promise.apply(e,[n].concat([].slice.call(arguments,1)))}</span>,useTapable:<span class="fstat-no" title="function not covered" >fu</span>nction(r,e,s){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,r,o,e){var s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(n,t,r,o){var e=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >H.get(n);<span class="cstat-no" title="statement not covered" ></span>if("string"!=typeof t.mode)<span class="cstat-no" title="statement not covered" >throw new Error("react-tapable: rawOptions' mode must be string");<span class="cstat-no" title="statement not covered" >i</span></span>f("tap"!==t.mode&amp;&amp;"tapAsync"!==t.mode&amp;&amp;"tapPromise"!==t.mode)<span class="cstat-no" title="statement not covered" >throw new Error("react-tapable: rawOptions' mode must be tap/tapAsync/tapPromise, but get "+t.mode);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.mode=t.mode,"string"!=typeof t.hook)<span class="cstat-no" title="statement not covered" >throw new Error("react-tapable: rawOptions' hook must be string, but get "+typeof t.hook);v</span></span>ar i=<span class="cstat-no" title="statement not covered" >s.getHook(t.hook);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("react-tapable: please check to see if the controller has this hook "+t.hook);<span class="cstat-no" title="statement not covered" >i</span></span>f(e.hook=i,e.type=x[e.mode],!(r instanceof Function))<span class="cstat-no" title="statement not covered" >throw new Error("react-tapable: rawOptions' fn must be function");<span class="cstat-no" title="statement not covered" >i</span></span>f(e.hook._isRegistered(e.type,r))<span class="cstat-no" title="statement not covered" >throw new Error("react-tapable: rawOptions' fn has been registered");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.fn=r,e.useAliasArr=o||[],e.context=Boolean(t.context),e.name=s.getHookTapName(t.hook),e}</span>(t,r,o,e),</span>i=<span class="cstat-no" title="statement not covered" >s.hook,</span>a=<span class="cstat-no" title="statement not covered" >s.context,</span>c=<span class="cstat-no" title="statement not covered" >s.fn,</span>u=<span class="cstat-no" title="statement not covered" >s.name,</span>l=<span class="cstat-no" title="statement not covered" >s.type,</span>f=<span class="cstat-no" title="statement not covered" >s.mode;<span class="cstat-no" title="statement not covered" ></span>n.useEffect(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return i[f]({context:a,name:u},c),<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >i._deleteTapHook(l,c)}</span>}</span>,[].concat(s.useAliasArr))}</span>(t+o,r,e,s)}</span>}}</span>var T=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError,</span>r=<span class="cstat-no" title="statement not covered" >n.onResult;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){<span class="cstat-no" title="statement not covered" >return t(r)}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t,o){<span class="cstat-no" title="statement not covered" >return"if("+t+" !== undefined) {\n"+r(t)+";\n} else {\n"+o()+"}\n"}</span>,resultReturns:n.resultReturns,onDone:n.onDone,rethrowIfPossible:n.rethrowIfPossible})}</span>,t}(c)),I=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],T.setup(this.fns,n),T.create(n)}</span>,o}</span>r(t,n);var o=t.prototype;return o.tapAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapAsync is not supported on a SyncHook")}</span>,o.tapPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapPromise is not supported on a SyncHook")}</span>,t}(l),O=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=function(n){var t=n.onError;return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){<span class="cstat-no" title="statement not covered" >return t(r)}</span>,onDone:n.onDone,rethrowIfPossible:n.rethrowIfPossible})},t}(c)),j=function(n){function t(t,r){var o;return(o=n.call(this,t,r)||this).compile=function(n){return this.fns=[],O.setup(this.fns,n),O.create(n)},o}r(t,n);var o=t.prototype;return o.tapAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapAsync is not supported on a SyncHook")}</span>,o.tapPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapPromise is not supported on a SyncHook")}</span>,t}(l),C=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >n.onError;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsLooping({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){<span class="cstat-no" title="statement not covered" >return t(r)}</span>,onDone:n.onDone,rethrowIfPossible:n.rethrowIfPossible})}</span>,t}(c)),W=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >return(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],C.setup(this.fns,n),C.create(n)}</span>,o}</span>r(t,n);var o=t.prototype;return o.tapAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapAsync is not supported on a SyncLoopHook")}</span>,o.tapPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapPromise is not supported on a SyncLoopHook")}</span>,t}(l),L=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >n.onError,</span>o=<span class="cstat-no" title="statement not covered" >n.onResult;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >return r(t)}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(e+="if("+r+" !== undefined) {\n",e+="if (!("+r+" instanceof Array)){ \n",e+=r+" = ["+r+"]\n",e+="}\n",t._args)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t._args.length;s++)<span class="cstat-no" title="statement not covered" >e+=["if ("+r+"["+s+"]) {",t._args[s]+" = "+r+"["+s+"];","}\n"].join("\n");<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn(e+="}\n")+o()}</span>,onDone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o("["+t._args.toString()+"]")}</span>,doneReturns:n.resultReturns,rethrowIfPossible:n.rethrowIfPossible})}</span>,t}(c)),B=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >if(t.length&lt;1)<span class="cstat-no" title="statement not covered" >throw new Error("WaterfallAll hooks must have at least one argument");<span class="cstat-no" title="statement not covered" >r</span></span>eturn(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],L.setup(this.fns,n),L.create(n)}</span>,o}</span>r(t,n);var o=t.prototype;return o.tapAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapAsync is not supported on a SyncHook")}</span>,o.tapPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapPromise is not supported on a SyncHook")}</span>,t}(l),F=new(function(n){function t(){return n.apply(this,arguments)||this}return r(t,n),t.prototype.content=<span class="fstat-no" title="function not covered" >fu</span>nction(n){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >n.onError,</span>o=<span class="cstat-no" title="statement not covered" >n.onResult;<span class="cstat-no" title="statement not covered" ></span>return this.callTapsSeries({onError:<span class="fstat-no" title="function not covered" >fu</span>nction(n,t){<span class="cstat-no" title="statement not covered" >return r(t)}</span>,onResult:<span class="fstat-no" title="function not covered" >fu</span>nction(n,r,o){var e=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e+="if("+r+" !== undefined) {\n",e+=t._args[0]+" = "+r+";\n",(e+="}\n")+o()}</span>,onDone:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return o(t._args[0])}</span>,doneReturns:n.resultReturns,rethrowIfPossible:n.rethrowIfPossible})}</span>,t}(c)),M=function(n){function <span class="fstat-no" title="function not covered" >t(</span>t,r){var o;<span class="cstat-no" title="statement not covered" >if(t.length&lt;1)<span class="cstat-no" title="statement not covered" >throw new Error("Waterfall hooks must have at least one argument");<span class="cstat-no" title="statement not covered" >r</span></span>eturn(o=n.call(this,t,r)||this).compile=<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return this.fns=[],F.setup(this.fns,n),F.create(n)}</span>,o}</span>r(t,n);var o=t.prototype;return o.tapAsync=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapAsync is not supported on a SyncHook")}</span>,o.tapPromise=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >throw new Error("tapPromise is not supported on a SyncHook")}</span>,t}(l);exports.AsyncParallelBailHook=p,exports.AsyncParallelHook=y,exports.AsyncSeriesBailHook=w,exports.AsyncSeriesHook=d,exports.AsyncSeriesLoopHook=g,exports.AsyncSeriesWaterfallAllHook=b,exports.AsyncSeriesWaterfallHook=A,exports.Controller=R,exports.SyncBailHook=I,exports.SyncHook=j,exports.SyncLoopHook=W,exports.SyncWaterfallAllHook=B,exports.SyncWaterfallHook=M,exports.createTapableController=D,exports.default=D;
//# sourceMappingURL=index.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Wed Jul 20 2022 22:30:09 GMT+0800 (China Standard Time)
            </div>
        </div>
        <script src="../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../sorter.js"></script>
        <script src="../block-navigation.js"></script>
    </body>
</html>
    